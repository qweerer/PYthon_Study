# IPVS

1. 加载模块

```shell
# 临时生效
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
 
# 永久生效
cat > /etc/sysconfig/modules/ipvs.modules <<EOF
modprobe -- ip_vs
modprobe -- ip_vs_rr
modprobe -- ip_vs_wrr
modprobe -- ip_vs_sh
modprobe -- nf_conntrack_ipv4
```

```conf
net.ipv4.ip_forward = 1
net.bridge.bridge-nf-call-iptables = 1
net.bridge.bridge-nf-call-ip6tables = 1
```

## dr模式（direct routing）

2. 设置虚拟ip(==vip==)

- 关闭`NetworkManager`: `systemctl disable NetworkManager && systemctl stop NetworkManager`
- 将主控机的`eth0`网卡加入`eth0:1`,ip地址为:==192.168.2.250==
- 将真实服务器的`lo`网卡加入`lo:1`,ip地址为:==192.168.2.250==, 与上面相同, `ifup lo`

```conf
# 主控
BOOTPROTO=static
DEVICE=eth0:1
ONBOOT=1
IPADDR=192.168.2.25
NETMASK=255.255.255.0

# 被控
DEVICE=lo:1
IPADDR=192.168.2.25
NETMASK=255.255.255.255
NETWORK=127.0.0.0
ONBOOT=1
```

> 或者用`ip`直接控制

```shell
ip addr add 192.168.2.25/24 dev eth0 label eth0:0
```

3. arp请求

- `arp-ignore` 有0-8种模式,但2-8用的很少
> ==0==: 只要配置IP, 就相应亲求 <br />
> ==1==: 请求目标到达相应网络接口,才相应请求

- `arp-announce`: arp通报行为
> ==0==: 任何接口都向外通报 <br />
> ==1==: 尽可能避免本网卡与不匹配目标通报 <br />
> ==2==: 只在本网卡经行通报


```sysctl.conf
# /etc/sysctl.conf
net.ipv4.conf.all.arp_ignore=1
net.ipv4.conf.defult.arp_ignore=1
net.ipv4.conf.lo.arp_ignore=1
net.ipv4.conf.all.arp_announce=2
net.ipv4.conf.defult.arp_announce=2
net.ipv4.conf.lo.arp_announce=2
```

4. 在被控的真实服务器中配置路由

```shell
route add -host 192.168.2.250 dev lo:1
```


### ipvsadm

```shell
# 添加一个集群服务器
# rr 平均分配，wrr 加权轮换, SH ip绑定, DS 正向代理常用
ipvsadm -A -t 192.168.2.250:80 -s rr
# 给该集群添加一个节点 -g的意思为--gatewaying (direct routing)
ipvsadm -a -t 192.168.2.250:80 -r 192.168.2.21:80 -g
# 编辑节点, 使他的数据持久化变为5秒
ipvsadm -E -t 192.168.2.250:80 -s rr -p 5
# 设置 tcp tcpfin udp 超时时间
ipvsadm --set 2 2 2 
ipvsadm --set 30 5 60 #一般情况
```



## nat模式

### ipvsadm

```shell
# 添加一个集群服务器, -p 为保存时间
ipvsadm -A -t 192.168.2.250:80 -s wrr -p 20
# 给该集群添加一个节点 -m的意思为nat模式
ipvsadm -a -t 192.168.2.250:80 -r 192.168.2.21:8 -m -w 1
ipvsadm -a -t 192.168.2.250:80 -r 192.168.2.22:8 -m -w 1
```


## keepalived

> 被控端配置
```c

## rs01
global_defs {
	router_id 12b01  # 身份id, 每个keepalived都不同
}

vrrp_instance vbox-0080 {         # 同一主备之间要一致
	state  MASTER              #当前节点在此虚拟路由器上的初始状态，状态为MASTER或者BACKUP
	interface eth0             # 公网网卡 绑定为当前虚拟路由器使用的物理接口，如：eth0,bond0,br0,可以和VIP不在一个网卡
	virtual_router_id 64       #每个虚拟路由器惟一标识，范围：0-255，在配置文件中必须唯一. 同属一个虚拟路由器的多个keepalived节点必须相同
	priority 100               #当前物理节点在此虚拟路由器的优先级，范围：1-254，主>背
	advert_int 1               #vrrp通告的时间间隔，默认1s检查一次主备是否正确
	authentication {           #认证机制
	  auth_type PASS           # AH|PASS
	  auth_pass <PASSWORD>     #预共享密钥，仅前8位有效，同一个虚拟路由器的多个keepalived节点必须一样
	}
	virtual_ipaddress {        #虚拟IP VIP
		# <IPADDR>/<MASK> brd <IPADDR> dev <STRING> scope <SCOPE> label <LABEL>
		# 192.168.200.100                             # 指定VIP，不指定网卡，默认为eth0,注意：不指定/prefix,默认为/32
		# 192.168.200.101/24 dev eth1                 #指定VIP的网卡
		1192.168.2.25/24 dev eth0 label eth0:1        #指定VIP的网卡label 
		# ip addr add 192.168.2.25/24 dev eth0 label eth0:0
	}
	track_interface {         #配置监控网络接口，一旦出现故障，则转为FAULT状态实现地址转移
		eth0
		eth1
		…
}

## rs02
global_defs {
	router_id 12b02  # 身份id, 每个keepalived都不同
}

vrrp_instance vbox-0080 {         # 同一主备之间要一致
	state  BACKUP              #当前节点在此虚拟路由器上的初始状态，状态为MASTER或者BACKUP
	interface eth0             # 公网网卡 绑定为当前虚拟路由器使用的物理接口，如：eth0,bond0,br0,可以和VIP不在一个网卡
	virtual_router_id 64       #每个虚拟路由器惟一标识，范围：0-255，在配置文件中必须唯一. 同属一个虚拟路由器的多个keepalived节点必须相同
	priority 50                #当前物理节点在此虚拟路由器的优先级，范围：1-254，主>背
	advert_int 1               #vrrp通告的时间间隔，默认1s检查一次主备是否正确
	authentication {           #认证机制
	  auth_type PASS           # AH|PASS
	  auth_pass <PASSWORD>     #预共享密钥，仅前8位有效，同一个虚拟路由器的多个keepalived节点必须一样
	}
	virtual_ipaddress {        #虚拟IP VIP
		# <IPADDR>/<MASK> brd <IPADDR> dev <STRING> scope <SCOPE> label <LABEL>
		# 192.168.200.100                             # 指定VIP，不指定网卡，默认为eth0,注意：不指定/prefix,默认为/32
		# 192.168.200.101/24 dev eth1                 #指定VIP的网卡
		1192.168.2.25/24 dev eth0 label eth0:1        #指定VIP的网卡label 
		# ip addr add 192.168.2.25/24 dev eth0 label eth0:0
	}
	track_interface {         #配置监控网络接口，一旦出现故障，则转为FAULT状态实现地址转移
		eth0
		eth1
		…
}
						 
```

> 主控端配置

```conf
# LVS CONFIGURATION 管理IVS
## ipvsadm通过命令
## keepalived 通过 配置文件控制1vs
#                vip 端口
# ipvsadm -A -t 10.0.0.3:80 -s wrr-p 20

virtual_server 10.0.0.3 80 {  # 创建组 池塘
	delay_loop 6
	1b_algo wrr               #轮询算法 1c least conn 小连接数
                              #wlc
                              #weighted round robin
    lb_kind DR                #1vs DR模式
    nat_mask 255.255.255.0    #vip对应的子网掩码
    persistence_timeout 50    #话保持时问 -p
    protocol TCP              #协议-t
    
	#ipvsadm-a-t 10.0.0.3：80 -r 10.0.0.11:80 -g -w 1
	real_server 10.0.0.11 80 {  # rs服务器的配置
		weight 1			    #权重
		TCP_CHECK {			    # -t TCP_CHECK 检查 传层 tep/udp 口
								#三次握手 建立连接 与你的端口建立连接
								#四次挥手
								#或者 指定ur1进行http检查 HTTP_GET
		connect_tineout 8
		nb_get_retry 3			# number of get retry 重试的次数
		delay_before_retry 3	#每次检查之前 等待3秒
		connect_port 80			# 检查端口
	}
		
	real_server 10.0.0.12 80 {  # rs服务器的配置
		weight 1			    #权重
		TCP_CHECK {			    # -t TCP_CHECK 检查 传层 tep/udp 口
								#三次握手 建立连接 与你的端口建立连接
								#四次挥手
								#或者 指定ur1进行http检查 HTTP_GET
		connect_tineout 8
		nb_get_retry 3			# number of get retry 重试的次数
		delay_before_retry 3	#每次检查之前 等待3秒
		connect_port 80			# 检查端口
	}
}


# TCP 10.0.0.3：80 wrr persistent 20
# -> 10.0.0.7：80     Route   1
# -> 10.0.0.8：80     Route   1
virtual_server 10.0.0.3 80 { 	# 创建组 泡塘
	delay_1oop 6
	1b_algo wrr              	# 轮询算法 1c least conn 最小连接数
								# aweighted round robin
	1b_kind DR					# Tvs DR模式
	nat_mask 255.255.255.0		# vip对应的子网掩码
	persistence_timeout 50		#公话保持时
	protocol TCP				#协议-t
}

```



```bash
# ceshi
ipvsadm -A -t 10.0.2.15:8080 -s rr
ipvsadm -a -t 10.0.2.15:8080 -r 127.0.0.1:18080 -m


ipvsadm -A -t 192.168.56.1:8080 -s rr
ipvsadm -a -t 192.168.56.1:8080 -r 127.0.0.1:18080 -m
```

---